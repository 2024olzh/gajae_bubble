<html><head><base href="https://life-cycle-candy-game.example.com" />
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>생애주기 마스터</title>
<style>
  body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #FFE5F1;
    font-family: 'Gothic', 'Nanum Gothic', 'Malgun Gothic', sans-serif;
  }
  #start-screen, #game-container, #end-screen {
    width: 400px;
    height: 600px;
    background-color: #FFF0F5;
    border: 3px solid #FF69B4;
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
    box-shadow: 0 10px 20px rgba(255, 105, 180, 0.3);
  }
  #game-container, #end-screen {
    display: none;
  }
  h1 {
    font-size: 24px;
    color: #000000;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(255, 105, 180, 0.3);
  }
  #rules {
    font-size: 16px;
    color: #000000;
    text-align: left;
    margin-bottom: 20px;
    padding-left: 20px;
  }
  input[type="text"] {
    width: 80%;
    padding: 10px;
    margin-bottom: 20px;
    border: 2px solid #FF69B4;
    border-radius: 10px;
    font-size: 16px;
    background-color: #FFF0F5;
    color: #000000;
  }
  #start-button, #restart-button {
    background-color: #FF69B4;
    border: none;
    padding: 15px 30px;
    font-size: 18px;
    color: white;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 5px 15px rgba(255, 105, 180, 0.4);
  }
  #start-button:hover, #restart-button:hover {
    background-color: #FF1493;
    transform: scale(1.05);
  }
  .candy {
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: #000000;
    text-align: center;
    word-break: keep-all;
    transition: all 0.05s;
    border-radius: 50%;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
    transform-style: preserve-3d;
  }
  .candy .emoji {
    font-size: calc(var(--size) * 0.7px);
    line-height: 1;
    margin-bottom: 5px;
  }
  .candy .name {
    font-size: calc(var(--size) * 0.16px);
    text-align: center;
  }
  .candy::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: inherit;
    filter: blur(4px);
    z-index: -1;
  }
  .candy::after {
    content: '';
    position: absolute;
    width: 40%;
    height: 40%;
    border-radius: 50%;
    background: rgba(255,255,255,0.7);
    top: 10%;
    left: 10%;
    filter: blur(2px);
  }
  #drop-zone {
    width: 360px;
    height: 50px;
    background-color: #FFB6C1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    border-radius: 10px;
  }
  #next-candy {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 16px;
    font-weight: bold;
    color: white;
    text-align: center;
    word-break: keep-all;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
  }
  #score, #timer {
    font-size: 18px;
    font-weight: bold;
    color: #000000;
  }
  #final-score {
    font-size: 24px;
    font-weight: bold;
    color: #000000;
    margin: 20px 0;
  }
  #preview-candy {
    position: absolute;
    top: 50px;
    pointer-events: none;
    opacity: 0.7;
    transition: left 0.1s ease-out;
  }
</style>
</head>
<body>
  <div id="start-screen">
    <h1>생애주기 마스터</h1>
    <div id="rules">
      1. 같은 생애 주기를 합쳐 더 높은 단계로 성장시키세요.<br>
      2. 2분 안에 가능한 많이 합쳐서 점수를 높이세요.<br>
      3. 생애 주기 단계가 높아질수록 더 많은 점수를 획득할 수 있습니다.<br>
      4. 제한 시간 내 최고 점수를 기록해 보세요!
    </div>
    <input type="text" id="nickname" placeholder="닉네임을 입력하세요">
    <button id="start-button">게임 시작!</button>
  </div>

  <div id="game-container">
    <div id="drop-zone">
      <div id="next-candy"></div>
      <div id="score">점수: 0</div>
      <div id="timer">2:00</div>
    </div>
    <div id="preview-candy"></div>
  </div>

  <div id="end-screen">
    <h1>게임 종료!</h1>
    <div id="final-score"></div>
    <button id="restart-button">다시 시작</button>
  </div>

<script>
const stages = [
  { name: '영유아기', color: '#FFB3BA', size: 50, emoji: '👶' },
  { name: '아동기', color: '#FFDFBA', size: 70, emoji: '🍭' },
  { name: '청소년기', color: '#FFFFBA', size: 90, emoji: '🎧' },
  { name: '성년기', color: '#BAFFC9', size: 110, emoji: '💼' },
  { name: '중년기', color: '#BAE1FF', size: 130, emoji: '🏡' },
  { name: '노년기', color: '#E1BAFF', size: 150, emoji: '🌺' }
];

let candies = [];
let nextCandyStage = 0;
let score = 0;
let playerNickname = "";
let timeLeft = 120;
let timerInterval;
let previewCandy;

document.getElementById('start-button').addEventListener('click', startGame);
document.getElementById('restart-button').addEventListener('click', restartGame);

function startGame() {
  playerNickname = document.getElementById('nickname').value.trim();
  if (playerNickname === "") {
    alert("닉네임을 입력해주세요!");
    return;
  }
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-container').style.display = 'flex';
  createPreviewCandy();
  updateNextCandy();
  updateScore();
  startTimer();
}

function restartGame() {
  score = 0;
  timeLeft = 120;
  candies.forEach(candy => candy.remove());
  candies = [];
  document.getElementById('end-screen').style.display = 'none';
  document.getElementById('game-container').style.display = 'flex';
  createPreviewCandy();
  updateNextCandy();
  updateScore();
  startTimer();
}

function createPreviewCandy() {
  previewCandy = document.createElement('div');
  previewCandy.id = 'preview-candy';
  previewCandy.className = 'candy';
  document.getElementById('game-container').appendChild(previewCandy);
  updatePreviewCandy();
}

function updatePreviewCandy() {
  previewCandy.style.backgroundColor = stages[nextCandyStage].color;
  
  previewCandy.innerHTML = '';
  const emojiSpan = document.createElement('span');
  emojiSpan.className = 'emoji';
  emojiSpan.textContent = stages[nextCandyStage].emoji;
  
  const nameSpan = document.createElement('span');
  nameSpan.className = 'name';
  nameSpan.textContent = stages[nextCandyStage].name;
  
  previewCandy.appendChild(emojiSpan);
  previewCandy.appendChild(nameSpan);
  
  const size = stages[nextCandyStage].size;
  previewCandy.style.width = size + 'px';
  previewCandy.style.height = size + 'px';
}

function startTimer() {
  updateTimer();
  timerInterval = setInterval(() => {
    timeLeft--;
    updateTimer();
    if (timeLeft <= 0) {
      endGame();
    }
  }, 1000);
}

function updateTimer() {
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;
  document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function endGame() {
  clearInterval(timerInterval);
  document.getElementById('game-container').style.display = 'none';
  document.getElementById('end-screen').style.display = 'flex';
  document.getElementById('final-score').textContent = `최종 점수: ${score}점`;
}

function createCandy(x, stage) {
  const candy = document.createElement('div');
  candy.className = 'candy';
  candy.style.backgroundColor = stages[stage].color;
  candy.style.left = x + 'px';
  candy.style.top = '50px';
  candy.dataset.stage = stage;
  
  const size = stages[stage].size;
  candy.style.setProperty('--size', size);
  
  const emojiSpan = document.createElement('span');
  emojiSpan.className = 'emoji';
  emojiSpan.textContent = stages[stage].emoji;
  
  const nameSpan = document.createElement('span');
  nameSpan.className = 'name';
  nameSpan.textContent = stages[stage].name;
  
  candy.appendChild(emojiSpan);
  candy.appendChild(nameSpan);
  
  candy.style.width = size + 'px';
  candy.style.height = size + 'px';
  
  document.getElementById('game-container').appendChild(candy);
  return candy;
}

function updateNextCandy() {
  nextCandyStage = Math.floor(Math.random() * 3);
  const nextCandy = document.getElementById('next-candy');
  nextCandy.style.backgroundColor = stages[nextCandyStage].color;
  
  nextCandy.innerHTML = '';
  const emojiSpan = document.createElement('span');
  emojiSpan.className = 'emoji';
  emojiSpan.textContent = stages[nextCandyStage].emoji;
  
  const nameSpan = document.createElement('span');
  nameSpan.className = 'name';
  nameSpan.textContent = stages[nextCandyStage].name;
  
  nextCandy.appendChild(emojiSpan);
  nextCandy.appendChild(nameSpan);
  
  updatePreviewCandy();
}

function updateScore() {
  document.getElementById('score').textContent = `${playerNickname}: ${score}`;
}

function dropCandy(x) {
  const candy = createCandy(x, nextCandyStage);
  candies.push(candy);
  updateNextCandy();
  moveCandy(candy);
}

function moveCandy(candy) {
  let y = parseFloat(candy.style.top);
  let vy = 0;
  const gravity = 0.5;
  const intervalId = setInterval(() => {
    vy += gravity;
    y += vy;
    candy.style.top = y + 'px';
    checkCollision(candy);
    if (y >= 550 - parseFloat(candy.style.height)) {
      y = 550 - parseFloat(candy.style.height);
      vy = 0;
      candy.style.top = y + 'px';
    }
    if (y >= 550 - parseFloat(candy.style.height) && Math.abs(vy) < 0.1) {
      clearInterval(intervalId);
    }
  }, 20);
}

function checkCollision(candy) {
  const rect1 = candy.getBoundingClientRect();
  for (let other of candies) {
    if (other === candy) continue;
    const rect2 = other.getBoundingClientRect();
    if (isColliding(rect1, rect2)) {
      if (candy.dataset.stage === other.dataset.stage) {
        mergeCandies(candy, other);
      } else {
        bounceCandies(candy, other);
      }
      break;
    }
  }
}

function isColliding(rect1, rect2) {
  const distance = Math.sqrt(
    Math.pow(rect1.left + rect1.width / 2 - (rect2.left + rect2.width / 2), 2) +
    Math.pow(rect1.top + rect1.height / 2 - (rect2.top + rect2.height / 2), 2)
  );
  return distance < (rect1.width + rect2.width) / 2;
}

function mergeCandies(candy1, candy2) {
  const stage1 = parseInt(candy1.dataset.stage);
  const stage2 = parseInt(candy2.dataset.stage);
  if (stage1 === stage2 && stage1 < stages.length - 1) {
    const newStage = stage1 + 1;
    const newX = (parseFloat(candy1.style.left) + parseFloat(candy2.style.left)) / 2;
    const newY = Math.min(parseFloat(candy1.style.top), parseFloat(candy2.style.top));
    candy1.remove();
    candy2.remove();
    candies = candies.filter(c => c !== candy1 && c !== candy2);
    const newCandy = createCandy(newX, newStage);
    newCandy.style.top = newY + 'px';
    candies.push(newCandy);
    moveCandy(newCandy);
    
    score += (newStage + 1) * 10;
    updateScore();
  }
}

function bounceCandies(candy1, candy2) {
  const dx = parseFloat(candy2.style.left) - parseFloat(candy1.style.left);
  const dy = parseFloat(candy2.style.top) - parseFloat(candy1.style.top);
  const distance = Math.sqrt(dx * dx + dy * dy);
  const nx = dx / distance;
  const ny = dy / distance;
  
  const speed = 5;
  const newX1 = parseFloat(candy1.style.left) - nx * speed;
  const newY1 = parseFloat(candy1.style.top) - ny * speed;
  const newX2 = parseFloat(candy2.style.left) + nx * speed;
  const newY2 = parseFloat(candy2.style.top) + ny * speed;
  
  candy1.style.left = `${Math.max(0, Math.min(400 - parseFloat(candy1.style.width), newX1))}px`;
  candy1.style.top = `${Math.max(50, Math.min(550 - parseFloat(candy1.style.height), newY1))}px`;
  candy2.style.left = `${Math.max(0, Math.min(400 - parseFloat(candy2.style.width), newX2))}px`;
  candy2.style.top = `${Math.max(50, Math.min(550 - parseFloat(candy2.style.height), newY2))}px`;
}

function continuousCollisionCheck() {
  for (let i = 0; i < candies.length; i++) {
    for (let j = i + 1; j < candies.length; j++) {
      const rect1 = candies[i].getBoundingClientRect();
      const rect2 = candies[j].getBoundingClientRect();
      if (isColliding(rect1, rect2)) {
        if (candies[i].dataset.stage === candies[j].dataset.stage) {
          mergeCandies(candies[i], candies[j]);
        } else {
          bounceCandies(candies[i], candies[j]);
        }
        return;
      }
    }
  }
}

document.getElementById('game-container').addEventListener('mousemove', (e) => {
  if (timeLeft > 0) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left - stages[nextCandyStage].size / 2;
    previewCandy.style.left = `${Math.max(0, Math.min(400 - stages[nextCandyStage].size, x))}px`;
  }
});

document.getElementById('game-container').addEventListener('click', (e) => {
  if (timeLeft > 0) {
    const x = parseFloat(previewCandy.style.left);
    dropCandy(x);
  }
});

setInterval(continuousCollisionCheck, 100);
</script>
</body></html>